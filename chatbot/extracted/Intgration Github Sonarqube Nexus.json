{
  "filename": "Intgration Github Sonarqube Nexus.pdf",
  "content": "Intégration de GitHub avec \nJoget, SonarQube, Nexus et \nAutomatisation via Docker\nÉtape 1 : Installation d’OpenSSH Server pour \nl’utilisation de Terminus\n1. Ouvrir un terminal sur votre machine virtuelle Ubuntu.\n2. Mettre à jour la liste des paquets :\n```bash\nsudo apt update\n```\n3. Installer OpenSSH Server :\n```bash\nsudo apt install openssh-server -y\n```\n4. Vérifier l’état du service SSH :\n```bash\nsudo systemctl status ssh\n```\nSi le service est actif (running), l’installation est réussie.\nSi SSH n’est pas en cours d’exécution, le démarrer :\n```bash\nsudo systemctl start ssh\n```\nActiver le démarrage automatique de SSH au boot :\n```bash\nsudo systemctl enable ssh\n```\nÉ\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n1\n\nÉtape 2 : Prérequis - Installation de Docker et Docker \nCompose\nAjout du dépôt Docker\n1. Ajouter la clé GPG officielle de Docker et configurer le dépôt :\n```bash\nsudo apt-get update\n```\n```bash\nsudo apt-get install ca-certificates curl\n```\n```bash\nsudo install -m 0755 -d /etc/apt/keyrings\n```\n```bash\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/ap\n```\nt/keyrings/docker.asc\n```bash\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n```\n2. Ajouter le dépôt Docker aux sources APT :\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/do\ncker.asc] https://download.docker.com/linux/ubuntu \\\n  $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODE\nNAME}\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n```bash\nsudo apt-get update\n```\nInstallation des paquets Docker\nPour installer la dernière version de Docker, exécutez :\n```bash\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugi\n```\nn docker-compose-plugin -y\nVérification des versions installées\n```bash\ndocker --version\n```\n```bash\ndocker compose version\n```\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n2\n\nÉtape 3 : Déploiement des Conteneurs Jenkins, \nSonarQube et Nexus avec Docker Compose\n1. Créer un fichier docker-compose.yml  et y ajouter la configuration suivante :\nversion: '3'\nservices:\n  jenkins:\n    image: jenkins/jenkins:lts\n    container_name: jenkins\n    ports:\n      - \"8081:8080\"\n      - \"50000:50000\"\n    volumes:\n      - jenkins_home:/var/jenkins_home\n  sonarqube:\n    image: sonarqube:latest\n    container_name: sonarqube\n    ports:\n      - \"9000:9000\"\n    environment:\n      - SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true\n  nexus:\n    image: sonatype/nexus3\n    container_name: nexus\n    ports:\n      - \"8082:8081\"\n      - \"8085:8085\"\nvolumes:\n  jenkins_home:\n2. Lancer les conteneurs en arrière-plan :\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n3\n\n```bash\ndocker compose up -d\n```\nRécupération des mots de passe par défaut\nJenkins :(Chercher la ligne indiquant le mot de passe initial)\n```bash\ndocker logs jenkins\n```\nSonarQube :Utilisateur par défaut : admin , Mot de passe par défaut : admin\nNexus :\n```bash\ndocker exec -it nexus cat /nexus-data/admin.password\n```\nÉtape 4 : Gestion des Branches GitHub dans un Projet \nJoget\n1. Initialisation du Projet et Configuration GitHub\n1.1 Création du projet et du référentiel\n1. Créer un projet Joget nommé my_app .\n2. Créer un dépôt GitHub du même nom ( my_app ).\n3. Partager un Token d’Authentification avec l’équipe via un canal privé (ex: \nSlack, Teams).\n1.2 Configuration de Git dans Joget\nDans Joget, aller dans :\nSettings → Git Config\nRemplir les champs suivants :\nURL du dépôt GitHub : https://github.com/mon-org/my_app.git\nNom d’utilisateur GitHub\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n4\n\nToken d’accès personnel (dans le champ mot de passe)\n2. Mise en place des branches Git\n2.1 Création de la branche principale ( main )\nVérifier que la branche main  existe bien :\ngit checkout -b main\ngit push origin main\nSi elle n’existe pas encore, la renommer :\ngit branch -M main\ngit push -u origin main\n2.2 Structuration des branches\nChaque développeur doit travailler sur une branche spécifique issue de main  :\ngit checkout -b my_app_2 main\ngit push origin my_app_2\ngit checkout -b my_app_3 main\ngit push origin my_app_3\nÉtape 5 : Extraction des Codes\nScript 1 : Extraction des Codes Java et SQL\nObjectif\nCe script est conçu pour extraire les morceaux de code Java et SQL des fichiers \nJSON et XML d'une application Joget.\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n5\n\nIl analyse les fichiers de formulaires JSON ainsi que le fichier appDefinition.xml  pour \ndétecter et extraire tout code pertinent, puis les enregistre dans des fichiers \ndistincts.\nExplication du Code\n1️⃣ Définition des Répertoires et Chemins\nBASE_DIR = \"/opt/joget/wflow/scripts/output\"\nFORMS_DIR = \"/opt/joget/wflow/app_src/vente_voitures/vente_voitures_1/form\ns\"\nAPPDEF_FILE = \"/opt/joget/wflow/app_src/vente_voitures/vente_voitures_1/ap\npDefinition.xml\"\nJAVA_DIR = os.path.join(BASE_DIR, \"java\")\nSQL_DIR = os.path.join(BASE_DIR, \"sql\")\nBASE_DIR : Dossier où les fichiers extraits seront stockés.\nFORMS_DIR : Contient les formulaires de l'application au format JSON.\nAPPDEF_FILE : Contient la définition de l'application avec du code Java et \nSQL.\nJAVA_DIR et SQL_DIR : Sous-dossiers où seront stockés respectivement les \ncodes Java et SQL.\n2️⃣ Création des Dossiers de Sortie\nos.makedirs(JAVA_DIR, exist_ok=True)\nos.makedirs(SQL_DIR, exist_ok=True)\nVérifie si les dossiers existent, sinon les crée pour stocker les fichiers extraits.\n3️⃣ Définition des Expressions Régulières\nJAVA_PATTERN = re.compile(r\"\\b(import java|public class|void main|System\\.\nout\\.println|PreparedStatement|Connection)\\b\")\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n6\n\nSQL_PATTERN = re.compile(r\"\\b(SELECT|INSERT|UPDATE|DELETE|CREATE|A\nLTER|DROP|TRUNCATE|FROM|WHERE)\\b\", re.IGNORECASE)\nJAVA_PATTERN : Identifie les scripts Java en recherchant des mots-clés \nJava.\nSQL_PATTERN : Identifie les requêtes SQL en détectant des mots-clés SQL \ncomme SELECT , INSERT , etc.\n4️⃣ Suppression des Fichiers Anciens\ndef clear_output_directory():\n    for directory in [JAVA_DIR, SQL_DIR]:\n        if os.path.exists(directory):\n            for file in os.listdir(directory):\n                file_path = os.path.join(directory, file)\n                try:\n                    os.remove(file_path)\n                except Exception as e:\n                    print(f\"⚠️ Impossible de supprimer {file_path}: {e}\")\nSupprime les fichiers précédemment générés pour éviter les doublons.\n5️⃣ Extraction et Enregistrement des Codes\ndef save_code(directory, base_name, extension, content, index):\n    file_name = f\"{base_name}_{index}.{extension}\"\n    file_path = os.path.join(directory, file_name)\n    with open(file_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(content)\n    print(f\"✅ Fichier généré : {file_path}\")\nCrée un fichier pour chaque extrait de code trouvé et l’enregistre sous un nom \nunique.\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n7\n\n6️⃣ Extraction des Codes des Fichiers JSON\ndef extract_code_from_json(file_path):\n    with open(file_path, \"r\", encoding=\"utf-8\") as f:\n        try:\n            data = json.load(f)\n        except json.JSONDecodeError:\n            print(f\"❌ ERREUR: Impossible de lire {file_path}\")\n            return\nOuvre et charge le fichier JSON.\nGère les erreurs en cas de JSON mal formé.\n  extracted_java = []\n    extracted_sql = []\n    def search_code(element):\n        if isinstance(element, dict):\n            for key, value in element.items():\n                if key == \"script\" and isinstance(value, str):\n                    if JAVA_PATTERN.search(value):\n                        extracted_java.append(value.strip())\n                    elif SQL_PATTERN.search(value):\n                        extracted_sql.append(value.strip())\n                elif isinstance(value, (dict, list)):\n                    search_code(value)\nRecherche récursive dans le JSON pour extraire les scripts Java et SQL.\n7️⃣ Extraction des Codes de appDefinition.xml\ndef extract_code_from_appdefinition():\n    if not os.path.exists(APPDEF_FILE):\n        print(f\"❌ ERREUR : Fichier {APPDEF_FILE} introuvable\")\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n8\n\n        return\n    tree = ET.parse(APPDEF_FILE)\n    root = tree.getroot()\n    extracted_java = []\n    extracted_sql = []\n    for elem in root.iter(\"pluginProperties\"):\n        raw_code = elem.text\n        if raw_code:\n            if JAVA_PATTERN.search(raw_code):\n                extracted_java.append(raw_code.strip())\n            elif SQL_PATTERN.search(raw_code):\n                extracted_sql.append(raw_code.strip())\nParcourt appDefinition.xml pour trouver les propriétés contenant du code \nJava ou SQL.\n8️⃣ Exécution du Script\nclear_output_directory()\nfor filename in os.listdir(FORMS_DIR):\n    if filename.endswith(\".json\"):\n        extract_code_from_json(os.path.join(FORMS_DIR, filename))\nextract_code_from_appdefinition()\nNettoie les anciens fichiers, puis exécute l'extraction sur tous les fichiers.\nScript 2 : Extraction des Scripts JavaScript\nObjectif\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n9\n\nCe script analyse les fichiers JSON des formulaires Joget pour extraire les scripts \nJavaScript intégrés.\nExplication du Code\n1️⃣ Définition des Chemins\nFORMS_DIR = \"/opt/joget/wflow/app_src/vente_voitures/vente_voitures_1/form\ns\"\nOUTPUT_JS_DIR = \"/opt/joget/wflow/scripts/output/js\"\nFORMS_DIR : Dossier contenant les fichiers JSON des formulaires.\nOUTPUT_JS_DIR : Dossier où seront stockés les fichiers JS extraits.\n2️⃣ Création du Dossier de Sortie\nos.makedirs(OUTPUT_JS_DIR, exist_ok=True)\nCrée le dossier js  si inexistant.\n3️⃣ Suppression des Anciens Scripts\nfor file in os.listdir(OUTPUT_JS_DIR):\n    file_path = os.path.join(OUTPUT_JS_DIR, file)\n    try:\n        os.remove(file_path)\n        print(f\"🗑️ Supprimé : {file_path}\")\n    except Exception as e:\n        print(f\"⚠️ Impossible de supprimer {file_path}: {e}\")\nSupprime tous les anciens fichiers JS.\n4️⃣ Extraction des Scripts JavaScript\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n10\n\ndef extract_js_from_json(file_path):\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n        scripts = []\n        def search_elements(elements):\n            if isinstance(elements, list):\n                for element in elements:\n                    search_elements(element)\n            elif isinstance(elements, dict):\n                if elements.get(\"className\") == \"org.joget.apps.form.lib.CustomHT\nML\":\n                    js_code = elements.get(\"properties\", {}).get(\"value\", \"\")\n                    if \"<script>\" in js_code:\n                        clean_js = re.sub(r\"<\\/?script.*?>\", \"\", js_code, flags=re.DOTAL\nL).strip()\n                        scripts.append(clean_js)\n                for key, value in elements.items():\n                    if isinstance(value, (dict, list)):\n                        search_elements(value)\n        search_elements(data.get(\"elements\", []))\n        return scripts\n    except json.JSONDecodeError as e:\n        print(f\"❌ Erreur JSON dans {file_path}: {e}\")\n        return []\nRecherche récursivement dans le JSON des scripts JavaScript, en les \nnettoyant des balises <script> .\n5️⃣ Sauvegarde des Scripts JS\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n11\n\nfor form_file in os.listdir(FORMS_DIR):\n    if form_file.endswith(\".json\"):\n        form_path = os.path.join(FORMS_DIR, form_file)\n        extracted_scripts = extract_js_from_json(form_path)\n        if extracted_scripts:\n            for index, script_content in enumerate(extracted_scripts, start=1):\n                script_filename = f\"{form_file.replace('.json', '')}_script_{index}.js\"\n                script_path = os.path.join(OUTPUT_JS_DIR, script_filename)\n                with open(script_path, \"w\", encoding=\"utf-8\") as script_file:\n                    script_file.write(script_content)\n                print(f\"✅ Fichier JS extrait : {script_path}\")\nStocke chaque script extrait sous forme de fichier .js .\nStructure des Répertoires\nAvant d'exécuter les scripts, assurez-vous que l'arborescence suivante est \nrespectée dans votre conteneur Joget.\n/opt/joget/wflow/\n│── app_src/\n│   └── vente_voitures/\n│       └── vente_voitures_1/\n│           ├── forms/                # Contient les fichiers JSON des formulaires\n│           │   ├── form1.json\n│           │   ├── form2.json\n│           │   └── ...\n│           ├── appDefinition.xml      # Fichier contenant la définition de l'applica\ntion\n│\n└── scripts/\n    ├── extract_code.py                # Script pour extraire Java et SQL\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n12\n\n    ├── extract_js.py                   # Script pour extraire JavaScript\n    ├── output/                         # Dossier contenant les fichiers générés\n    │   ├── java/\n    │   ├── sql/\n    │   ├── js/\n    │   └── ...\nDéploiement des Scripts\n1. Copiez les fichiers extract_code.py  et extract_js.py  dans le répertoire \n/opt/joget/wflow/scripts/ .\n```bash\ndocker exec -it jogetapp \n```\ncd /opt/joget/wflow/scripts\nextract_code.py\nextract_js.py\nÉtape 6 : Configuration du Conteneur Joget ( jogetapp )\nAvant d'exécuter les scripts et d'automatiser l'extraction des codes, il est essentiel \nd'installer certains outils et de configurer l'environnement dans le conteneur \nJoget ( jogetapp ).\n1️⃣ Accéder au Conteneur Joget\nTout d'abord, ouvrez un terminal et entrez dans le conteneur Joget en exécutant :\n```bash\ndocker exec -it jogetapp \n```\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n13\n\nVous serez maintenant dans l’environnement du conteneur.\n2️⃣ Mise à Jour et Installation des Outils Nécessaires\nDans le conteneur, exécutez les commandes suivantes :\nMettre à jour les paquets existants\napt update && apt upgrade -y\nInstaller les outils de base\napt install -y wget unzip 3 3-pip nano vim\nwget  : Permet de télécharger des fichiers à partir d’Internet.\nunzip  : Utilisé pour extraire des fichiers compressés.\n3  : Langage requis pour exécuter les scripts d'extraction.\n3-pip  : Gestionnaire de paquets  (utile si des dépendances doivent être \ninstallées).\nnano  et vim  : Éditeurs de texte pour modifier des fichiers si nécessaire.\nÉtape 7 : Analyse de Code avec SonarQube\nL’objectif de cette étape est d’installer et configurer SonarQube Scanner, d’activer \nl’analyse de code pour Java, SQL et JavaScript, et d’intégrer le plugin SQL pour \nSonarQube.\n1️⃣ Générer un Token d'Authentification dans \nSonarQube\nAvant de lancer l’analyse, SonarQube nécessite un token d’authentification. \nSuivez ces étapes pour générer un token personnel :\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n14\n\n1. Se connecter à SonarQube\nAccédez à votre instance SonarQube (exemple : http://localhost:9000 ).\nConnectez-vous avec un compte administrateur ( admin  / admin  par défaut).\n2. Créer un token\nDans le menu en haut à droite, cliquez sur \"Mon compte\".\nAllez dans l’onglet \"Sécurité\".\nEntrez un nom pour le token (ex: jenkins-sonar-token ).\nCliquez sur \"Générer\".\nCopiez et enregistrez le token affiché (⚠️ Vous ne pourrez plus le voir \naprès).\n3. Utilisation dans Jenkins\nDans Jenkins → Gestion des Credentials, ajoutez une nouvelle Credential \n:\nType : Secret Text\nID : SONAR_TOKEN\nValeur : (collez le token généré).\n2️⃣ Installation de SonarQube Scanner\nExplication du Stage : Prepare SonarQube Scanner\nCe stage vérifie si SonarQube Scanner est installé sur la machine Jenkins et \nl’installe si nécessaire.\nstage('Prepare SonarQube Scanner') {\n    steps {\n        script {\n            echo \"🔍 Checking if SonarQube Scanner is installed...\"\n        }\n        sh '''\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n15\n\n            if [ ! -d \"sonar-scanner\" ]; then\n                echo \"🚀 Installing SonarQube Scanner...\"\n                apt-get update && apt-get install -y wget unzip\n                wget -q https://binaries.sonarsource.com/Distribution/sonar-scanne\nr-cli/sonar-scanner-cli-5.0.1.3006-linux.zip -O sonar-scanner.zip\n                unzip -q sonar-scanner.zip\n                mv sonar-scanner-5.0.1.3006-linux sonar-scanner\n                chmod +x sonar-scanner/bin/sonar-scanner\n            else\n                echo \"✅ SonarQube Scanner is already installed.\"\n            fi\n        '''\n    }\n}\nExplication des commandes\nVérifie si le répertoire sonar-scanner  existe.\nSi non, il :\nMet à jour les paquets.\nInstalle wget  et unzip  (au cas où ils ne sont pas installés).\nTélécharge SonarQube Scanner CLI v5.0.1.3006.\nDécompresse et renomme le dossier en sonar-scanner .\nRend l’exécutable sonar-scanner/bin/sonar-scanner  utilisable.\n3️⃣ Installation du Plugin SQL pour SonarQube\nPar défaut, SonarQube ne supporte pas l'analyse des fichiers SQL. Il faut donc \najouter un plugin tiers qui permet de scanner les fichiers SQL.\nInstallation du Plugin SQL\n1. Vérifier et mettre à jour Java\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n16\n\njava -version\nSonarQube requiert Java 17+.\nSi vous avez une version inférieure, mettez à jour Java :\n```bash\nsudo apt update\n```\n```bash\nsudo apt install openjdk-17-jdk\n```\njava -version\nDéfinir Java 17 comme version par défaut :\n```bash\nsudo update-alternatives --config java\n```\n2. Cloner le plugin SQL SonarQube\ngit clone https://github.com/gretard/sonar-sql-plugin.git\ncd sonar-sql-plugin\n3. Compiler et installer le plugin\nmvn versions:display-dependency-updates spotless:check spotless:apply \ninstall\n4. Déployer le plugin dans SonarQube\nCopier le fichier .jar  généré vers le dossier des plugins SonarQube :\n```bash\ndocker cp sonar-sql-plugin/src/sonar-sql-plugin/target/sonar-sql-plug\n```\nin-1.1.0.jar sonarqube:/opt/sonarqube/extensions/plugins/\nRedémarrer SonarQube :\n```bash\ndocker restart sonarqube\n```\n4️⃣’\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n17\n\n4️⃣ Exécution de l’Analyse avec SonarQube\nUne fois SonarQube Scanner installé et le plugin SQL ajouté, nous pouvons \nanalyser notre code.\nExplication du Stage : SonarQube Analysis\nstage('SonarQube Analysis') {\n    steps {\n        sh '''\n            if [ -d \"./output/java\" ] || [ -d \"./output/sql\" ] || [ -d \"./output/js\" ]; then\n                echo \"✅ Files found, proceeding with SonarQube analysis...\"\n                sonar-scanner/bin/sonar-scanner \\\n                  -Dsonar.projectKey=voitures \\\n                  -Dsonar.projectName=voitures \\\n                  -Dsonar.host.url=\"${SONAR_HOST_URL}\" \\\n                  -Dsonar.login=\"${SONAR_TOKEN}\" \\\n                  -Dsonar.sources=./output \\\n                  -Dsonar.inclusions=\"**/*.java,**/*.sql,**/*.js\" \\\n                  -Dsonar.java.binaries=. \\\n                  -Dsonar.scm.disabled=true \\\n                  -Dsonar.sourceEncoding=UTF-8 \\\n                  -Dsonar.verbose=true\n            else\n                echo \"🚨 ERROR: No Java, SQL, or JS files found in ./output!\"\n                exit 1\n            fi\n        '''\n    }\n}\nExplication des paramètres\nVérifie la présence des fichiers à analyser ( Java, SQL, JS ).\nLance SonarQube Scanner en définissant les options :\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n18\n\nDsonar.projectKey=voitures  : Nom du projet dans SonarQube.\nDsonar.projectName=voitures  : Nom affiché dans SonarQube.\nDsonar.host.url=\"${SONAR_HOST_URL}\"  : URL du serveur SonarQube.\nDsonar.login=\"${SONAR_TOKEN}\"  : Utilise le token d’authentification.\nDsonar.sources=./output  : Spécifie le répertoire contenant les fichiers extraits.\nDsonar.inclusions=\"**/*.java,**/*.sql,**/*.js\"  : Spécifie les fichiers à analyser.\nDsonar.java.binaries=.  : Indique où trouver les fichiers binaires Java.\nDsonar.scm.disabled=true  : Désactive l’analyse du gestionnaire de versions (Git).\nDsonar.sourceEncoding=UTF-8  : Définit l’encodage des fichiers source.\nDsonar.verbose=true  : Active le mode verbeux pour plus de logs.\nÉtape 8 : Exportation et Upload du fichier JWA vers \nNexus\nL'objectif de cette étape est d'exporter l'application Joget sous forme de fichier \nJWA et de l'envoyer dans un repository Nexus pour stockage et gestion.\n1️⃣ Création d’un Repository Nexus\nAvant de pouvoir uploader le fichier JWA, il est nécessaire de configurer un \nrepository Nexus.\nAccéder à Nexus\n1. Ouvrir Nexus Repository Manager via l'URL :\nhttp://192.168.193.128:8082\n2. Se connecter avec :\nUtilisateur : admin\nMot de passe : (retrouvé via docker exec -it nexus cat /nexus-data/admin.password )\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n19\n\nCréer un Repository RAW Hosted\nNous allons créer un repository Raw Hosted, car nous voulons stocker un fichier \nJWA qui ne correspond pas aux formats standard comme Maven ou npm.\n1. Aller dans l'interface Nexus\nSe connecter à Nexus Repository Manager.\nAller dans \"Repositories\".\nCliquer sur \"Create repository\".\n2. Choisir le type de repository\nSélectionner \"raw (hosted)\".\n3. Configurer le repository\nName : vente_voitures-repo\nVersion policy : Release\nDeployment policy : Allow redeploy\n4. Enregistrer la configuration.\n2️⃣ Explication du Stage Export & Upload JWA to Nexus\nCe stage effectue trois actions principales :\n1. Exporter l'application Joget sous forme de fichier .jwa .\n2. Vérifier la validité du fichier exporté.\n3. Uploader le fichier sur Nexus.\nstage('Export & Upload JWA to Nexus (joget-repo)') {\n    steps {\n        script {\n            echo \"📦 Exporting application RSU from Joget...\"\n        }\n        sh '''\n        # Définition des variables\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n20\n\n        APP_NAME=\"vente_voitures\"\n        APP_ID=\"1\"\n        TIMESTAMP=$(date +\"%Y%m%d%H%M%S\")\n        JWA_FILE=\"APP_${APP_NAME}-${APP_ID}-${TIMESTAMP}.jwa\"\n        EXPORT_PATH=\"/opt/joget/wflow/export\"\n        echo \"📦 Exporting: Name=$APP_NAME, ID=$APP_ID, File=$JWA_FILE\"\n        # Installation de zip dans le conteneur Joget si nécessaire\n        docker exec -u root jogetapp  -c \"apt-get update && apt-get install -y zi\np\"\n        # Création du dossier d'exportation et modification des permissions\n        docker exec -u root jogetapp  -c \"mkdir -p ${EXPORT_PATH} && chmod -\nR 777 ${EXPORT_PATH}\"\n        # Exporter l'application en tant que fichier JWA\n        docker exec jogetapp  -c \"cd /opt/joget/wflow/app_src && zip -r ${EXPO\nRT_PATH}/${JWA_FILE} ${APP_NAME} -x \\\"${APP_NAME}/.git/*\\\"\"\n        # Vérifier la taille du fichier exporté\n        FILE_SIZE=$(docker exec jogetapp  -c \"stat -c %s ${EXPORT_PATH}/${J\nWA_FILE}\")\n        if [ \"$FILE_SIZE\" -lt 1024 ]; then\n            echo \"❌ ERROR: Exported JWA file seems empty (size: ${FILE_SIZE} \nbytes).\"\n            exit 1\n        fi\n        echo \"✅ Export successful! File: ${JWA_FILE} (Size: ${FILE_SIZE} byte\ns)\"\n        # Copier le fichier JWA exporté de Joget vers Jenkins\n        docker cp jogetapp:${EXPORT_PATH}/${JWA_FILE} .\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n21\n\n        if [ ! -f \"${JWA_FILE}\" ]; then\n            echo \"❌ ERROR: JWA file was not copied correctly to Jenkins.\"\n            exit 1\n        fi\n        echo \"📤 Uploading ${JWA_FILE} to Nexus...\"\n        # Upload du fichier vers Nexus\n        curl -u admin:Mouhamed2000** --upload-file ${JWA_FILE} \\\n        \"http://192.168.193.128:8082/repository/vente_voitures-repo/com/voiture\ns/jwa/${APP_ID}/${JWA_FILE}\"\n        echo \"✅ Upload completed successfully to joget-repo!\"\n        '''\n    }\n}\n3️⃣ Explication du Code\n1. Définition des Variables\nAPP_NAME=\"vente_voitures\"\nAPP_ID=\"1\"\nTIMESTAMP=$(date +\"%Y%m%d%H%M%S\")\nJWA_FILE=\"APP_${APP_NAME}-${APP_ID}-${TIMESTAMP}.jwa\"\nEXPORT_PATH=\"/opt/joget/wflow/export\"\nAPP_NAME  : Nom de l'application.\nAPP_ID  : Identifiant de l'application.\nTIMESTAMP  : Génère un timestamp pour avoir un fichier unique \n( YYYYMMDDHHMMSS ).\nJWA_FILE  : Nom du fichier .jwa  qui sera exporté.\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n22\n\nEXPORT_PATH  : Chemin où le fichier sera stocké dans le conteneur Joget.\n2. Installation et Préparation du Conteneur Joget\n```bash\ndocker exec -u root jogetapp  -c \"apt-get update && apt-get install -y zip\"\n```\n```bash\ndocker exec -u root jogetapp  -c \"mkdir -p ${EXPORT_PATH} && chmod -R 77\n```\n7 ${EXPORT_PATH}\"\nInstalle zip  si ce n’est pas déjà installé.\nCrée le dossier d’exportation et donne les permissions nécessaires.\n3. Export de l'Application en .jwa\n```bash\ndocker exec jogetapp  -c \"cd /opt/joget/wflow/app_src && zip -r ${EXPORT_P\n```\nATH}/${JWA_FILE} ${APP_NAME} -x \\\"${APP_NAME}/.git/*\\\"\"\nCompresse l’application Joget située dans /opt/joget/wflow/app_src  en excluant le \ndossier .git .\nStocke le fichier compressé dans ${EXPORT_PATH} .\n4. Vérification de l'Exportation\nFILE_SIZE=$(docker exec jogetapp  -c \"stat -c %s ${EXPORT_PATH}/${JWA_\nFILE}\")\nif [ \"$FILE_SIZE\" -lt 1024 ]; then\n    echo \"❌ ERROR: Exported JWA file seems empty (size: ${FILE_SIZE} byte\ns).\"\n    exit 1\nfi\nVérifie la taille du fichier exporté.\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n23\n\nSi la taille est inférieure à 1 Ko, on considère que le fichier est vide et on \narrête le processus.\n5. Copie du Fichier JWA vers Jenkins\n```bash\ndocker cp jogetapp:${EXPORT_PATH}/${JWA_FILE} .\n```\nCopie le fichier depuis le conteneur vers Jenkins pour l'envoyer à Nexus.\nif [ ! -f \"${JWA_FILE}\" ]; then\n    echo \"❌ ERROR: JWA file was not copied correctly to Jenkins.\"\n    exit 1\nfi\nVérifie si le fichier a bien été copié.\n6. Upload du Fichier JWA vers Nexus\n```bash\ncurl -u admin:Mouhamed2000** --upload-file ${JWA_FILE} \\\n```\n\"http://192.168.193.128:8082/repository/vente_voitures-repo/com/voitures/jwa/\n${APP_ID}/${JWA_FILE}\"\nUtilise curl  pour envoyer le fichier vers Nexus.\nAuthentification avec l’utilisateur admin  et mot de passe.\nChemin Nexus :\nhttp://192.168.193.128:8082/repository/vente_voitures-repo/com/voitures/j\nwa/1/APP_vente_voitures-1-<timestamp>.jwa\nUne fois le fichier uploadé, un message ✅ Upload completed successfully to joget-repo!  est \naffiché.\nÉtape 9 : Explication Complète du Pipeline Jenkins\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n24\n\npipeline.sh\nCe pipeline Jenkins est conçu pour :\n✅ \nRécupérer le code source depuis GitHub.\n✅ Exporter et stocker l’application Joget sous forme de fichier .jwa  dans Nexus.\n✅ Configurer et exécuter SonarQube Scanner pour analyser les fichiers Java, \nSQL et JavaScript.\n✅ Exécuter des scripts  pour extraire du code de Joget.\n✅ Envoyer une notification par e-mail en cas de succès ou d’échec du pipeline.\n📌 Structure Générale\npipeline {\n    agent any\n    environment {\n        SONAR_HOST_URL = 'http://192.168.193.128:9000'\n        SONAR_TOKEN = 'squ_b6986d26e43b9a5c9fe5c8247fb84abdb22995a\n4'\n    }\nExplication :\nagent any  : Le pipeline s'exécute sur n'importe quel agent disponible dans \nJenkins.\nenvironment  : Définit les variables d’environnement pour SonarQube :\nSONAR_HOST_URL  : URL du serveur SonarQube.\nSONAR_TOKEN  : Token d’authentification pour SonarQube.\n1️⃣\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n25\n\n1️⃣ Stage : Checkout Code\nstage('Checkout Code') {\n    steps {\n        script {\n            echo \"📥 Cloning repository: main\"\n        }\n        git branch: 'main', url: 'https://github.com/motrabelsi10/testpipeline.git'\n    }\n}\nExplication :\nRécupère le code source depuis GitHub.\nAffiche un message de confirmation.\n2️⃣ Stage : Export & Upload JWA to Nexus\nstage('Export & Upload JWA to Nexus (joget-repo)') {\n    steps {\n        script {\n            echo \"📦 Exporting application RSU from Joget...\"\n        }\n        sh '''\n        APP_NAME=\"vente_voitures\"\n        APP_ID=\"1\"\n        TIMESTAMP=$(date +\"%Y%m%d%H%M%S\")\n        JWA_FILE=\"APP_${APP_NAME}-${APP_ID}-${TIMESTAMP}.jwa\"\n        EXPORT_PATH=\"/opt/joget/wflow/export\"\n        echo \"📦 Exporting: Name=$APP_NAME, ID=$APP_ID, File=$JWA_FILE\"\n        docker exec -u root jogetapp  -c \"apt-get update && apt-get install -y zi\np\"\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n26\n\n        docker exec -u root jogetapp  -c \"mkdir -p ${EXPORT_PATH} && chmod -\nR 777 ${EXPORT_PATH}\"\n        docker exec jogetapp  -c \"cd /opt/joget/wflow/app_src && zip -r ${EXPO\nRT_PATH}/${JWA_FILE} ${APP_NAME} -x \\\"${APP_NAME}/.git/*\\\"\"\n        FILE_SIZE=$(docker exec jogetapp  -c \"stat -c %s ${EXPORT_PATH}/${J\nWA_FILE}\")\n        if [ \"$FILE_SIZE\" -lt 1024 ]; then\n            echo \"❌ ERROR: Exported JWA file seems empty (size: ${FILE_SIZE} \nbytes).\"\n            exit 1\n        fi\n        echo \"✅ Export successful! File: ${JWA_FILE} (Size: ${FILE_SIZE} byte\ns)\"\n        docker cp jogetapp:${EXPORT_PATH}/${JWA_FILE} .\n        if [ ! -f \"${JWA_FILE}\" ]; then\n            echo \"❌ ERROR: JWA file was not copied correctly to Jenkins.\"\n            exit 1\n        fi\n        echo \"📤 Uploading ${JWA_FILE} to Nexus...\"\n        curl -u admin:Mouhamed2000** --upload-file ${JWA_FILE} \\\n        \"http://192.168.193.128:8082/repository/vente_voitures-repo/com/voiture\ns/jwa/${APP_ID}/${JWA_FILE}\"\n        echo \"✅ Upload completed successfully to joget-repo!\"\n        '''\n    }\n}\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n27\n\nExplication :\nExporte l'application Joget sous format .jwa .\nVérifie la validité du fichier (taille > 1 Ko).\nCopie le fichier de Joget vers Jenkins.\nUpload vers Nexus.\n3️⃣ Stage : Installation du Scanner SonarQube\nstage('Prepare SonarQube Scanner') {\n    steps {\n        script {\n            echo \"🔍 Checking if SonarQube Scanner is installed...\"\n        }\n        sh '''\n            if [ ! -d \"sonar-scanner\" ]; then\n                echo \"🚀 Installing SonarQube Scanner...\"\n                apt-get update && apt-get install -y wget unzip\n                wget -q https://binaries.sonarsource.com/Distribution/sonar-scanne\nr-cli/sonar-scanner-cli-5.0.1.3006-linux.zip -O sonar-scanner.zip\n                unzip -q sonar-scanner.zip\n                mv sonar-scanner-5.0.1.3006-linux sonar-scanner\n                chmod +x sonar-scanner/bin/sonar-scanner\n            else\n                echo \"✅ SonarQube Scanner is already installed.\"\n            fi\n        '''\n    }\n}\nExplication :\nVérifie si SonarQube Scanner est déjà installé, sinon il l’installe.\n4️⃣\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n28\n\n4️⃣ Stage : Préparation de Joget\nstage('Prepare Joget Environment') {\n    steps {\n        sh 'docker exec -i jogetapp  -c \"mkdir -p /opt/joget/wflow/scripts/output \n&& chmod -R 777 /opt/joget/wflow/scripts/output\"'\n    }\n}\nExplication :\nCrée le répertoire output  pour stocker les fichiers extraits.\nAssigne les permissions nécessaires.\n5️⃣ Stage : Exécution des Scripts \nstage('Run  Script') {\n    steps {\n        sh '''\n            docker exec -i jogetapp  -c \"3 /opt/joget/wflow/scripts/extract_code.p\ny\"\n            docker exec -i jogetapp  -c \"3 /opt/joget/wflow/scripts/extract_js.py\"\n        '''\n    }\n}\nExplication :\nExécute les scripts  pour extraire le code Java, SQL et JavaScript de Joget.\n6️⃣ Stage : Copie des Fichiers Extraits\nstage('Copy Extracted Files to Jenkins') {\n    steps {\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n29\n\n        sh '''\n            rm -rf output\n            mkdir -p output/java output/sql output/js\n            docker cp jogetapp:/opt/joget/wflow/scripts/output/java ./output/\n            docker cp jogetapp:/opt/joget/wflow/scripts/output/sql ./output/\n            docker cp jogetapp:/opt/joget/wflow/scripts/output/js ./output/\n        '''\n    }\n}\nExplication :\nSupprime les anciens fichiers.\nCopie les nouveaux fichiers extraits vers Jenkins.\n7️⃣ Stage : Vérification des Fichiers\nstage('Verify Extracted Files in Jenkins') {\n    steps {\n        sh 'ls -R ./output || echo \"🚨 No extracted files found!\"'\n    }\n}\nExplication :\nAffiche les fichiers extraits ou une alerte si aucun fichier n’a été trouvé.\n8️⃣ Stage : Analyse SonarQube\nstage('SonarQube Analysis') {\n    steps {\n        sh '''\n            if [ -d \"./output/java\" ] || [ -d \"./output/sql\" ] || [ -d \"./output/js\" ]; then\n                echo \"✅ Files found, proceeding with SonarQube analysis...\"\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n30\n\n                sonar-scanner/bin/sonar-scanner \\\n                  -Dsonar.projectKey=voitures \\\n                  -Dsonar.projectName=voitures \\\n                  -Dsonar.host.url=\"${SONAR_HOST_URL}\" \\\n                  -Dsonar.login=\"${SONAR_TOKEN}\" \\\n                  -Dsonar.sources=./output \\\n                  -Dsonar.inclusions=\"**/*.java,**/*.sql,**/*.js\" \\\n                  -Dsonar.sourceEncoding=UTF-8 \\\n                  -Dsonar.verbose=true\n            else\n                echo \"🚨 ERROR: No Java, SQL, or JS files found in ./output!\"\n                exit 1\n            fi\n        '''\n    }\n}\nExplication :\nVérifie la présence de fichiers.\nExécute l’analyse SonarQube.\n📨 Notifications par E-mail\npost {\n    success {\n        script {\n            mail to: 'mouhamedtrabelsi.28@gmail.com',\n                 subject: \"Succès du build: ${env.JOB_NAME} #${env.BUILD_NUMB\nER}\",\n                 body: \"Le build a réussi ! Consultez le lien suivant : ${env.BUILD_UR\nL}\"\n        }\n    }\n    failure {\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n31\n\n        script {\n            mail to: 'mouhamedtrabelsi.28@gmail.com',\n                 subject: \"Échec du build: ${env.JOB_NAME} #${env.BUILD_NUMBE\nR}\",\n                 body: \"Le build a échoué ! Consultez le lien suivant : ${env.BUILD_U\nRL}\"\n        }\n    }\n}\nExplication :\nEnvoie une notification par e-mail en cas de succès ou d’échec.\n🚀 Ce pipeline assure une automatisation complète du cycle CI/CD avec Joget, \nNexus et SonarQube !\nIntégration de GitHub avec Joget, SonarQube, Nexus et Automatisation via Docker\n32\n\n"
}